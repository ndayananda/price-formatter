{"version":3,"file":"price-formatter.module.js","sources":["../src/index.js","../src/formatter.js"],"sourcesContent":["import { getPriceFormatter } from './formatter';\r\n\r\nexport default class PriceFormatter {\r\n  constructor(pattern) {\r\n    this.pattern = pattern;\r\n    this.formatPrice = getPriceFormatter(pattern);\r\n  }\r\n\r\n  format(value) {\r\n    if (isNaN(value)) {\r\n      throw new TypeError(`${value} is NaN`);\r\n    }\r\n    return this.formatPrice(Number(value));\r\n  }\r\n\r\n  getPattern() {\r\n    return this.pattern;\r\n  }\r\n}","/**\r\n *\ttoFixed method returns the number fixed to precession decimal value\r\n *\r\n * @param {Number} number\r\n * @param {Number} precision\r\n * @access public\r\n * @returns {Number} returns the number fixed to passed precission\r\n */\r\nfunction toFixed(number, precision) {\r\n  return Number(number).toFixed(precision);\r\n}\r\n\r\n/**\r\n *\tencodePattern method encodes the pattern provided by replacing\r\n * currency with !, negetive with ^, decimal/optional with ., thousand separator with ,\r\n * and returns encodedPattern\r\n *\r\n * @param {String} pattern, pattern to be used to format the value\r\n * @returns {String} encodedPattern, like ^#,###,###,###.##!\r\n */\r\nfunction encodePattern(pattern) {\r\n  return pattern.replace(/(\\{c.*?\\})/gi, '!').replace(/(\\{n.*?\\})/gi, '^').replace(/(\\{[d|o].*?\\})/gi, '.').replace(/(\\{.*?\\})/gi, ',')\r\n}\r\n\r\n/**\r\n *\tdecodePattern method is recursive function which decodeds the pattern provided and\r\n * returns format parameters like symbol, negetive, decimal, isDecimalOptional, group\r\n *\r\n * @param {String} pattern, pattern to be used to format the value\r\n * @returns {Object} params, parameters like symbol, negetive, decimal, isDecimalOptional, group\r\n */\r\nfunction decodePattern(pattern, params = {}, regex = /(\\{([c|n|t|o|d])(.*?)\\})/gi, matches = regex.exec(pattern)) {\r\n  if(!matches) return params;\r\n\r\n  const map = { c: 'symbol', n: 'negative', d: 'decimal', o: 'decimal', t: 'group'};\r\n\r\n  params[map[matches[2].toLowerCase()]] = matches[3];\r\n\r\n  if(matches[2].toLowerCase() === 'o') params['isDecimalOptional'] = true;\r\n\r\n  return decodePattern(pattern, params, regex, matches = regex.exec(pattern));\r\n}\r\n\r\n/**\r\n *\tgetFormatOptions method returns a few simple characteristics of the pattern provided\r\n *\r\n * @param {String} pattern, pattern to be used to format the value\r\n * @returns {Object} returns an object with values for pattern, decimalPlaces, leftSpacing, groups, spacing\r\n */\r\nfunction getFormatOptions(pattern) {\r\n  const params = decodePattern(pattern),\r\n    encodedPattern = encodePattern(pattern),\r\n    numberFormatPattern = encodedPattern.trim().match(/[#0,.]+/)[0],\r\n    split = numberFormatPattern.split('.'),\r\n    decimalChars = split[0],\r\n    decimalMantissa = split[1],\r\n    groups = decimalChars.split(','),\r\n    spacing = encodedPattern.split(numberFormatPattern);\r\n\r\n  return Object.assign({}, {\r\n    pattern: encodedPattern,\r\n    decimalPlaces: typeof decimalMantissa === 'undefined' ? 0 : decimalMantissa.length,\r\n    leftSpacing: spacing[0],\r\n    rightSpacing: spacing[1],\r\n    groupLengths: groups.map((group) => {\r\n      return group.length;\r\n    })\r\n  }, params);\r\n}\r\n\r\n/**\r\n *\tformatDecimalChars method returns formatted Decimal Charecters w.r.t pattern\r\n *\r\n * @param {Object} formatOptions, the options to format decimal chars\r\n * @param {Array} formatOptions.groupLengths, array of decimal char groups like [1,3,3,3]\r\n * @param {String} formatOptions.separator, decimal char separator\r\n * @param {String} formatOptions.number, decimal chars number to be formatted\r\n * @returns {Object} {num, formattedNumber}\r\n */\r\nfunction formatDecimalChars({groupLengths = [], separator = ',', number = '0'}) {\r\n  return [...groupLengths].reverse().reduce(({num, formattedNumber}, curr) => {\r\n      return {\r\n        num: num.substring(0, num.length - curr),\r\n        formattedNumber: num.substring(num.length - curr).length ? (formattedNumber.length ? `${num.substring(num.length - curr)}${separator}${formattedNumber}` : `${num.substring(num.length - curr)}`) : formattedNumber\r\n      };\r\n  }, {num: number, formattedNumber: ''});\r\n}\r\n\r\n/**\r\n *\tformatDecimalMantissa method returns formatted Decimal Mantissa w.r.t pattern\r\n *\r\n * @param {Number} inputValue, inputValue to be formatted\r\n * @param {String} number, Decimal Mantissa\r\n * @param {Object} options, the options to format decimal mantissa\r\n * @returns {String} formatDecimalMantissa\r\n */\r\nfunction formatDecimalMantissa(inputValue, number, options) {\r\n  return typeof number === 'undefined' || (options.isDecimalOptional && Number.isInteger(inputValue)) ? '' : `${options.decimal}${number}`;\r\n}\r\n\r\n/**\r\n *\tformat method returns formattedNumber w.r.t pattern\r\n *\r\n * @param {Number} number\r\n * @param {Object} options\r\n * @returns {String} formattedNumber\r\n */\r\nfunction format(number, options) {\r\n  const formattedValue = toFixed(Math.abs(number), options.decimalPlaces),\r\n    splitNumber = formattedValue.split('.');\r\n\r\n  let {formattedNumber} = formatDecimalChars({groupLengths: options.groupLengths, separator: options.group, number: splitNumber[0]});\r\n\r\n  formattedNumber = `${options.leftSpacing}${formattedNumber}${formatDecimalMantissa(number, splitNumber[1], options)}${options.rightSpacing}`;\r\n\r\n  return formattedNumber\r\n    .replace(/\\^/g, number < 0 ? options.negative || '-' : '')\r\n    .replace(/!/g, options.symbol)\r\n    .trim()\r\n    .replace(/\\s/g, 'Â '); // Replacing space with the non breaking space ASCII code (alt+255), this makes price & currency symbol a single word without break\r\n}\r\n\r\nexport function getPriceFormatter(pattern) {\r\n  const formatOptions = getFormatOptions(pattern);\r\n  return (value) => format(value, formatOptions);\r\n}"],"names":["constructor","pattern","this","formatPrice","formatOptions","params","decodePattern","regex","matches","exec","c","n","d","o","t","toLowerCase","encodedPattern","replace","encodePattern","numberFormatPattern","trim","match","split","decimalMantissa","groups","spacing","Object","assign","decimalPlaces","length","leftSpacing","rightSpacing","groupLengths","map","group","getFormatOptions","value","number","options","splitNumber","precision","Number","toFixed","Math","abs","formattedNumber","separator","reverse","reduce","num","curr","substring","formatDecimalChars","inputValue","isDecimalOptional","isInteger","decimal","formatDecimalMantissa","negative","symbol","format","getPriceFormatter","isNaN","TypeError","getPattern"],"mappings":"qBAGEA,YAAYC,GACVC,KAAKD,QAAUA,EACfC,KAAKC,qBCqHyBF,GAChC,MAAMG,EA1ER,SAA0BH,GACxB,MAAMI,EAnBR,SAASC,EAAcL,EAASI,EAAS,GAAIE,EAAQ,6BAA8BC,EAAUD,EAAME,KAAKR,IACtG,OAAIO,GAIJH,EAFY,CAAEK,EAAG,SAAUC,EAAG,WAAYC,EAAG,UAAWC,EAAG,UAAWC,EAAG,SAE9DN,EAAQ,GAAGO,gBAAkBP,EAAQ,GAEhB,MAA7BA,EAAQ,GAAGO,gBAAuBV,EAAM,mBAAwB,GAE5DC,EAAcL,EAASI,EAAQE,EAAOC,EAAUD,EAAME,KAAKR,KAR9CI,EAkBLC,CAAcL,GAC3Be,EA/BJ,SAAuBf,GACrB,OAAOA,EAAQgB,QAAQ,eAAgB,KAAKA,QAAQ,eAAgB,KAAKA,QAAQ,mBAAoB,KAAKA,QAAQ,cAAe,KA8B9GC,CAAcjB,GAC/BkB,EAAsBH,EAAeI,OAAOC,MAAM,WAAW,GAC7DC,EAAQH,EAAoBG,MAAM,KAElCC,EAAkBD,EAAM,GACxBE,EAFeF,EAAM,GAECA,MAAM,KAC5BG,EAAUT,EAAeM,MAAMH,GAEjC,OAAOO,OAAOC,OAAO,GAAI,CACvB1B,QAASe,EACTY,mBAA0C,IAApBL,EAAkC,EAAIA,EAAgBM,OAC5EC,YAAaL,EAAQ,GACrBM,aAAcN,EAAQ,GACtBO,aAAcR,EAAOS,IAAKC,GACjBA,EAAML,SAEdxB,GAwDmB8B,CAAiBlC,GACvC,OAAQmC,GAjBV,SAAgBC,EAAQC,GACtB,MACEC,EArGJ,SAAiBF,EAAQG,GACvB,OAAOC,OAAOJ,GAAQK,QAAQF,GAmGPE,CAAQC,KAAKC,IAAIP,GAASC,EAAQV,eAC1BN,MAAM,KAErC,IAAIuB,gBAACA,GAhCP,UAA4Bb,aAACA,EAAe,GAAhBc,UAAoBA,EAAY,IAAhCT,OAAqCA,EAAS,MACxE,MAAO,IAAIL,GAAce,UAAUC,OAAO,EAAEC,IAAAA,EAAKJ,gBAAAA,GAAkBK,KACxD,CACLD,IAAKA,EAAIE,UAAU,EAAGF,EAAIpB,OAASqB,GACnCL,gBAAiBI,EAAIE,UAAUF,EAAIpB,OAASqB,GAAMrB,OAAUgB,EAAgBhB,OAAU,GAAEoB,EAAIE,UAAUF,EAAIpB,OAASqB,KAAQJ,IAAYD,IAAqB,GAAEI,EAAIE,UAAUF,EAAIpB,OAASqB,GAAWL,IAEvM,CAACI,IAAKZ,EAAQQ,gBAAiB,KA0BVO,CAAmB,CAACpB,aAAcM,EAAQN,aAAcc,UAAWR,EAAQJ,MAAOG,OAAQE,EAAY,KAI9H,OAFAM,EAAmB,GAAEP,EAAQR,cAAce,IAjB7C,SAA+BQ,EAAYhB,EAAQC,GACjD,YAAyB,IAAXD,GAA2BC,EAAQgB,mBAAqBb,OAAOc,UAAUF,GAAe,GAAM,GAAEf,EAAQkB,UAAUnB,IAgBnEoB,CAAsBpB,EAAQE,EAAY,GAAID,KAAWA,EAAQP,eAEvHc,EACJ5B,QAAQ,MAAOoB,EAAS,EAAIC,EAAQoB,UAAY,IAAM,IACtDzC,QAAQ,KAAMqB,EAAQqB,QACtBvC,OACAH,QAAQ,MAAO,KAKA2C,CAAOxB,EAAOhC,GDvHXyD,CAAkB5D,GAGvC2D,OAAOxB,GACL,GAAI0B,MAAM1B,GACR,UAAU2B,UAAa3B,EAAF,WAEvB,YAAYjC,YAAYsC,OAAOL,IAGjC4B,aACE,YAAY/D"}